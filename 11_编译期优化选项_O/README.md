# 第十一节：编译期优化选项（二）——O（上）

## 一篇很简单的代码

    int createNum();
    void putNum(int a);

    int sum(int a,int b)
    {
        return a+b;
    }

    int main()
    {
        int x=createNum();
        int y=createNum();
        int z=sum(x,y);
        putNum(z);
        return 0;
    }

我们来查看一下它的汇编代码：

    g++ -s main.cpp

得到一个main.s。打开这个文件，截取其中main函数的一小段，加上一些注释，如下：

    call    _Z9createNumv   ;调用createNum()函数
    movl    %eax, -4(%rbp)  ;将返回值压栈
    call    _Z9createNumv   ;再调用createNum()函数
    movl    %eax, -8(%rbp)  ;将返回值压栈
    movl    -8(%rbp), %edx  ;将栈顶数据放在寄存器edx中
    movl    -4(%rbp), %eax  ;同上，放在寄存器eax中
    movl    %edx, %esi      ;将寄存器edx中的数据作为sum()函数的第一个参数
    movl    %eax, %edi      ;将寄存器eax中的数据作为sum()函数的第二个参数
    call    _Z3sumii        ;调用sum()函数
    movl    %eax, -12(%rbp) ;将返回值压栈
    movl    -12(%rbp), %eax ;将栈顶数据放在寄存器eax中
    movl    %eax, %edi      ;将寄存器eax中的数据作为putNum()函数的第一个参数
    call    _Z6putNumi      ;调用putNum()函数

## 初步优化

大家觉得，是不是很麻烦？

每次调用一个函数之后，先压栈，然后又转到寄存器中，这很浪费时间。

gcc会这么笨吗？当然不会。
gcc的-O选项（注意，是大写。回想一下，小写-o选项是干什么的？前面讲过）就是用来处理编译期优化的。

我们重新产生一下汇编代码，但是使用-O选项。

    g++ -O -s main.cpp -o main.O1.s

现在打开main.O1.s文件，
看，里面函数的返回值没有经过入栈和出栈的过程，
直接传入下一个函数的参数。这样减少了六条汇编代码。

## 进一步优化

可是细想想，sum()函数有点多余。
它实际上只是做了一个加法，
但是我们仍然需要调用这个函数来完成它的功能。

gcc会这么笨吗？
当然不会。

-O选项还可以加数字，表示优化的级别。

没有数字默认是1，最大可以加到3。
优化级别越高，产生的代码的执行效率就越高。

我们用级别2试一下：

    g++ -O2 -s main.cpp -o main.O2.s

现在打开main.O2.s，
大家可以看到，调用sum()函数的代码都不见了，
取而代之的是一条加法指令来完成两个整数的相加。

-O3的效果我就不试了。而且，如果不加-O选项，优化级别就是0。

## 编译效率

既然-O后面的的数字越大，产生的代码越优化，那么为什么不直接用-O3？

原因是，优化的级别越高，
虽然最后生成的代码的执行效率就会越高，
但是编译的过程花费的时间就会越长。

在执行效率和编译时间之间，
需要做出一个权衡。

gcc没有擅自做这个决定，
而是把决定的权力留给了用户。

在linux的世界里，有这样一个观点：
不限制用户的发挥，
但是让用户为自己的行为负责。

所以linux的很多软件都有很多选项。

这样有好处也有坏处，
好处是，用户拥有更多的权力，
坏处就是，彩笔们一看到这么多选项，瞬间就傻了。

## 本节完
